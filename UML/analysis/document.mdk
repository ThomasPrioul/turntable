Doc class     : [10pt]article
Title         : Pont tournant pour le modélisme ferroviaire
Sub Title     : Cahier d'analyse
Author        : Thomas Prioul
Affiliation   : Polytech' Tours
Email         : thomas.prioul@etu.univ-tours.fr
Locale        : fr-FR

Colorizer     : cpp
Logo          : True
name-contents : Table des matières

<!--
Bib style     : plainnat
Bibliography  : example
-->

[TITLE]
[TOC]




# Introduction {-}

Ce document contient la démarche d'analyse pour le projet "pont tournant pour le modélisme ferroviaire".
On y retrouve les diagrammes UML permettant de représenter le système et ses différents composants logiciels, qui sont le coeur de la réalisation de ce projet.

On rappellera d'abord le contexte du projet, avant de présenter les analyses qui ont été faites.



# Objectif

Cette partie est un bref rappel du cahier de spécifications.

Il s'agit de réaliser un pont tournant pour le modélisme ferroviaire, commandé par une RaspberryPi 2 dotée d'un écran tactile. Ce pont s'intègre dans un système existant composé d'une partie "manuelle" où les trains et les aiguillages sont commandés directement par l'utilisateur, et d'une partie automatisée où des scripts décrivent les itinéraires des trains (les aiguillages et signalisations sont changés en conséquence). **Ce système est géré par un serveur central sur lequel plusieurs clients peuvent venir se connecter.**

Le pont tourne à l'aide d'un moteur pas à pas, commandé par une carte "driver", elle-même connectée à la RaspberryPi via des GPIO.

## Liste des fonctionnalités souhaitées

La RaspberryPi devra présenter une interface homme-machine afin de pouvoir contrôler sur place la rotation du pont. De plus, elle devra reprendre certains éléments d'un client existant afin de contrôler le reste du réseau de modélisme (comme le dépôt faisant l'interface entre partie manuelle et automatisée du circuit).

On retrouve au final quatre fonctionnalités principales:

* Commander la plaque tournante,
* Commander les aiguillages du dépot,
* Commander le déplacement d'une locomotive,
* Lancer des scripts parmi une liste et qui agiront sur la partie automatisée.

Enfin, la plaque tournante devra pouvoir être contrôlée à distance (c'est-à-dire depuis un autre client du système), ce qui implique une modification du serveur existant pour relayer les messages du client vers la RaspberryPi.

Le projet est réalisé pour **M. Cédric Charles**, qui possède la maquette de modélisme ferroviaire à son domicile.

## Attentes
Le but est avant tout d'avoir une plaque tournante commandée depuis la RaspberryPi, ainsi que la commande du dépôt, des trains et des scripts.

Si le temps le permet, le programme pourrait être étendu afin de remplacer le client PC vieillissant ainsi qu'un client pour smartphone écrit en Java et dont le développement n'est plus actif.
Le client doit donc être multi-plateforme et léger (pour les cibles Android).

La modification du serveur est également optionnelle, elle n'est pas essentielle à la réalisation du projet.

## Domaines techniques

En résumé, le projet implique :

* électronique,
* mécanique,
* et informatique embarquée.

C'est la partie informatique embarquée qui est analysée dans ce document, les parties mécanique et électronique étant déjà conçues et en cours de fabrication par M. Charles.



# Architecture

Dans cette section, nous voyons l'architecture envisagée pour les composants logiciels du projet.

## Structure du système

Voici un rappel de la structure du système existant, avec la place que prend la RaspberryPi dans ce système.

~ Figure { #fig-synoptic; caption: "Synoptique du système" }
![synoptic]
~ 

On remarque que la RaspberryPi occupe deux rôles dans ce système. Nous y reviendrons dans la section [#software_decomposition].

Dans le cahier de spécifications, nous avons présenté les diagrammes en blocs de chacun des sous-systèmes du schéma précédent.
Notamment, les blocs logiciels sur la RaspberryPi avaient été présentés. Voici ci-dessous le diagramme présenté dans le cahier de spécifications.

~ Figure { #fig-rpi_soft; caption: "Blocs logiciels RaspberryPi" }
![rpi_software]
~

On y voit deux blocs principaux, qui sont **DCC client GUI** et **Turntable worker**. Ces blocs ont des fonctions bien différentes et sont présentés dans la partie suivante.

## Décomposition des logiciels { #software_decomposition }

Afin de séparer au mieux les tâches que doit réaliser l'informatique embarquée, il a été décidé de séparer le projet en deux **logiciels** (processus) distincts :

* Une **interface graphique**, qui sera un client du serveur central via un socket TCP.
* Un **service** pour le contrôle de la plaque tournante, qui sera un programme en ligne de commande connecté au serveur central via un socket TCP. Dans cette relation, le **service** est un serveur et ce qu'on a auparavant appelé "serveur central" (serveur DCC) est un client.

~ Note
On appellera respectivement ces logiciels "**client DCC**" et "**service plaque tournante**" par la suite.
~

~ Note
On appellera le serveur central du système le "**serveur DCC**" par la suite.
~

Cela permet deux choses :

* Distribuer le même code du client pour chaque plateforme cible, sans se soucier du support sur lequel il est exécuté, et sans compilation conditionnelle.
* Séparer la notion de **service plaque tournante** de celle de **client** du système, permettant l'exploitation de la plaque par un autre client lorsque le logiciel graphique n'est pas lancé sur la RaspberryPi. Ce deuxième logiciel sera un démon système (un service) sur l'OS Linux et sera donc dédié au pilotage de la plaque tournante.

Séparer les programmes en deux permet également de simplifier la mise en oeuvre de pilotage de la plaque tournante, car on peut simuler les ordres venant du réseau à l'aide d'un serveur de test, ou même directement envoyer des trames depuis le client DCC à l'aide d'un socket TCP. Enfin, les deux fonctionnalités peuvent être développées en parralèle sans incidence sur le fonctionnement de l'une ou l'autre.

Il a été décidé d'implémenter le client DCC en C++ avec le framework Qt5, car c'est un vrai framework multi-plateforme (Windows, Linux, Mac, iPhone, Android...) et qu'il est assez léger. Il est également gratuit dans sa version "community".

Le service plaque tournante sera lui implémenté en C/C++, et peut-être avec Qt pour l'unification des codes sources et la simplicité d'utilisation des sockets (à confirmer lors de la réalisation). La librairie WiringPi (en C) permettra de contrôler les GPIO de la RaspberryPi.

Maintenant que nous avons présenté les deux composants logiciels, nous allons voir l'analyse UML qui a été réalisée pour chacun d'eux.

## Analyse UML

### Client DCC

Pour bien représenter l'application dans son ensemble, il faut identifier sa composante principale. Ici, la composante principale est le réseau. C'est l'état du réseau et de la connexion avec le serveur qui déterminent l'évolution de l'application. C'est pourquoi nous allons commencer par une représentation en machine d'état de l'application.

#### Diagramme de machine d'état

~ Figure { #fig-statemachine; caption: "Machine d'état de l'application" }
![statemachine]
~

On retrouve deux états principaux dans l'application : 

* L'état de connexion inactive,
* L'état de connexion active.

##### Connexion inactive

Dans l'état de connexion inactive, l'utilisateur est limité à certaines interfaces utilisateur lui permettant de configurer le client, et notamment la connexion réseau.

C'est donc logiquement que l'on retrouve deux sous-états : 

* Non configuré,
* Prêt à démarrer.

Le passage d'un état à un autre se fait via le remplissage des champs de connexion dans l'interface utilisateur.
L'utilisateur n'a plus qu'à utiliser un bouton de connexion pour changer d'état principal (vers connexion active).

Bien évidemment, l'utilisateur peut quitter l'application à tout moment, peut importe l'état dans lequel elle se trouve. Il est possible que des états de transition existent pour nettoyer les ressources utilisées, par exemple.

##### Connexion active

Dans cet état, on retrouve le cas d'utilisation principal de l'application, qui est d'exploiter les informations et les commandes données par le serveur DCC.

#### Diagramme de classes

Voici un découpage en classes du logiciel graphique

~ Figure { #fig-classdiagram; caption: "Diagramme de classes" }
![classdiagram]
~

### Service plaque tournante

## Machine d'état de l'application




![software_arch]


[synoptic]: images/synoptic.png "synoptic" { width:auto; max-width:90% }
[classdiagram]: images/classdiagram.png "classdiagram" { width:auto; max-width:100% }
[statemachine]: images/statemachine.png "statemachine" { width:auto; max-width:100% }
[software_arch]: images/software_arch.png "software_arch" { width:auto; max-width:70% }
[rpi_software]: images/rpi_software.png "rpi_software" { width:auto; max-width:90% }
